/*
 * Ais-Stream WebsocketObjects
 * OpenAPI 3.0 definitions for the data models used by aisstream.io.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.homebeaver.aismodel;

import java.io.IOException;
//import org.openapitools.client.model.AddressedBinaryMessageApplicationID;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;

import org.json.JSONException;
import org.json.JSONObject;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import io.swagger.annotations.ApiModelProperty;

/**
 * AddressedBinaryMessage Message ID 6 contains an Application specific messages
 * <p>
 * Rec. ITU-R M.1371-4 page 55:
 * 5.3.1 Addressed Messages 6 and 12
Addressed messages should have a destination user ID. The source station should anticipate an
acknowledgement message (Message 7 or Message 13). If an acknowledgement is not received the
station should retry the transmission. The station should wait 4 s before attempting retries. When a
transmission is retried, the retransmit flag should be set to retransmitted. The number of retries
should be 3, but it could be configurable between 0 and 3 retries by an external application via the
presentation interface. When set to a different value by an external application, the number of
retries should default to 3 retries after 8 min. The overall result of the data transfer should be
forwarded to above layers. The acknowledgement should be between transport layers in two
stations.
Each data transfer packet on the presentation interface should have a unique packet identifier
consisting of the message type (binary or safety related messages), the source-ID, the destination-
ID, and a sequence number.
The sequence number should be assigned in the appropriate presentation interface message which is
input to the station.
The destination station should return the same sequence number in its acknowledgement message
on the presentation interface.
The source station should not reuse a sequence number until it has been acknowledged or time-out
has occurred.
The acknowledgement should be put first in the data transfer queue both on the presentation
interface and on the VDL.
These acknowledgements are applicable only to the VDL. Other means must be employed for
acknowledging applications.

VDL : VHF data link
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-06-27T20:57:25.293422-07:00[America/Vancouver]")
public class AddressedBinaryMessage extends AisMessage {

	/*
	 * 0-3
	 */
  public static final String SERIALIZED_NAME_SEQUENCEINTEGER = "Sequenceinteger";
  @SerializedName(SERIALIZED_NAME_SEQUENCEINTEGER)
  private Integer sequenceinteger;

  /**
   * MMSI number of destination station
   */
  public static final String SERIALIZED_NAME_DESTINATION_I_D = "DestinationID";
  @SerializedName(SERIALIZED_NAME_DESTINATION_I_D)
  private Integer destinationID;

  public static final String SERIALIZED_NAME_RETRANSMISSION = "Retransmission";
  @SerializedName(SERIALIZED_NAME_RETRANSMISSION)
  private Boolean retransmission;

  public static final String SERIALIZED_NAME_SPARE = "Spare";
  @SerializedName(SERIALIZED_NAME_SPARE)
  private Boolean spare;

  public static final String SERIALIZED_NAME_APPLICATION_I_D = "ApplicationID";
  @SerializedName(SERIALIZED_NAME_APPLICATION_I_D)
  private AddressedBinaryMessageApplicationID applicationID;

  public static final String SERIALIZED_NAME_BINARY_DATA = "BinaryData";
  @SerializedName(SERIALIZED_NAME_BINARY_DATA)
  private String binaryData;

	public AddressedBinaryMessage() {
		super();
	}

  public AddressedBinaryMessage sequenceinteger(Integer sequenceinteger) {
    this.sequenceinteger = sequenceinteger;
    return this;
  }

   /**
   * Get sequenceinteger
   * @return sequenceinteger
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Integer getSequenceinteger() {
    return sequenceinteger;
  }


  public void setSequenceinteger(Integer sequenceinteger) {
    this.sequenceinteger = sequenceinteger;
  }


  public AddressedBinaryMessage destinationID(Integer destinationID) {
    
    this.destinationID = destinationID;
    return this;
  }

   /**
   * Get destinationID
   * @return destinationID
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Integer getDestinationID() {
    return destinationID;
  }


  public void setDestinationID(Integer destinationID) {
    this.destinationID = destinationID;
  }


  public AddressedBinaryMessage retransmission(Boolean retransmission) {
    
    this.retransmission = retransmission;
    return this;
  }

   /**
   * Get retransmission
   * @return retransmission
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Boolean getRetransmission() {
    return retransmission;
  }


  public void setRetransmission(Boolean retransmission) {
    this.retransmission = retransmission;
  }


  public AddressedBinaryMessage spare(Boolean spare) {
    
    this.spare = spare;
    return this;
  }

   /**
   * Get spare
   * @return spare
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Boolean getSpare() {
    return spare;
  }


  public void setSpare(Boolean spare) {
    this.spare = spare;
  }


  public AddressedBinaryMessage applicationID(AddressedBinaryMessageApplicationID applicationID) {
    
    this.applicationID = applicationID;
    return this;
  }

   /**
   * Get applicationID
   * @return applicationID
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public AddressedBinaryMessageApplicationID getApplicationID() {
    return applicationID;
  }


  public void setApplicationID(AddressedBinaryMessageApplicationID applicationID) {
    this.applicationID = applicationID;
  }


  public AddressedBinaryMessage binaryData(String binaryData) {
    
    this.binaryData = binaryData;
    return this;
  }

   /**
   * Get binaryData
   * @return binaryData
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public String getBinaryData() {
    return binaryData;
  }


  public void setBinaryData(String binaryData) {
    this.binaryData = binaryData;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AddressedBinaryMessage addressedBinaryMessage = (AddressedBinaryMessage) o;
    return Objects.equals(getMessageID(), addressedBinaryMessage.getMessageID()) &&
           Objects.equals(getRepeatIndicator(), addressedBinaryMessage.getRepeatIndicator()) &&
           Objects.equals(getUserID(), addressedBinaryMessage.getUserID()) &&
           Objects.equals(getValid(), addressedBinaryMessage.getValid()) &&
        Objects.equals(this.sequenceinteger, addressedBinaryMessage.sequenceinteger) &&
        Objects.equals(this.destinationID, addressedBinaryMessage.destinationID) &&
        Objects.equals(this.retransmission, addressedBinaryMessage.retransmission) &&
        Objects.equals(this.spare, addressedBinaryMessage.spare) &&
        Objects.equals(this.applicationID, addressedBinaryMessage.applicationID) &&
        Objects.equals(this.binaryData, addressedBinaryMessage.binaryData);
  }

  @Override
  public int hashCode() {
	return Objects.hash(getMessageID(), getRepeatIndicator(), getUserID(), getValid(), 
	sequenceinteger, destinationID, retransmission, spare, applicationID, binaryData);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AddressedBinaryMessage {\n");
    sb.append("    messageID: ").append(toIndentedString(getMessageID())).append("\n");
    sb.append("    repeatIndicator: ").append(toIndentedString(getRepeatIndicator())).append("\n");
    sb.append("    userID: ").append(toIndentedString(getUserID())).append("\n");
    sb.append("    valid: ").append(toIndentedString(getValid())).append("\n");
    sb.append("    sequenceinteger: ").append(toIndentedString(sequenceinteger)).append("\n");
    sb.append("    destinationID: ").append(toIndentedString(destinationID)).append("\n");
    sb.append("    retransmission: ").append(toIndentedString(retransmission)).append("\n");
    sb.append("    spare: ").append(toIndentedString(spare)).append("\n");
    sb.append("    applicationID: ").append(toIndentedString(applicationID)).append("\n");
    sb.append("    binaryData: ").append(toIndentedString(binaryData)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("MessageID");
    openapiFields.add("RepeatIndicator");
    openapiFields.add("UserID");
    openapiFields.add("Valid");
    openapiFields.add("Sequenceinteger");
    openapiFields.add("DestinationID");
    openapiFields.add("Retransmission");
    openapiFields.add("Spare");
    openapiFields.add("ApplicationID");
    openapiFields.add("BinaryData");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("MessageID");
    openapiRequiredFields.add("RepeatIndicator");
    openapiRequiredFields.add("UserID");
    openapiRequiredFields.add("Valid");
    openapiRequiredFields.add("Sequenceinteger");
    openapiRequiredFields.add("DestinationID");
    openapiRequiredFields.add("Retransmission");
    openapiRequiredFields.add("Spare");
    openapiRequiredFields.add("ApplicationID");
    openapiRequiredFields.add("BinaryData");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AddressedBinaryMessage
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (AddressedBinaryMessage.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in AddressedBinaryMessage is not found in the empty JSON string", AddressedBinaryMessage.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!AddressedBinaryMessage.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AddressedBinaryMessage` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AddressedBinaryMessage.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // validate the optional field `ApplicationID`
      if (jsonObj.getAsJsonObject("ApplicationID") != null) {
        AddressedBinaryMessageApplicationID.validateJsonObject(jsonObj.getAsJsonObject("ApplicationID"));
      }
      if (jsonObj.get("BinaryData") != null && !jsonObj.get("BinaryData").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BinaryData` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BinaryData").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AddressedBinaryMessage.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AddressedBinaryMessage' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AddressedBinaryMessage> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AddressedBinaryMessage.class));

       return (TypeAdapter<T>) new TypeAdapter<AddressedBinaryMessage>() {
           @Override
           public void write(JsonWriter out, AddressedBinaryMessage value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AddressedBinaryMessage read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

	public static AddressedBinaryMessage fromJson(JSONObject jo) {
		AisMessage res = new AddressedBinaryMessage();
		AddressedBinaryMessage abm = null;
		// Extract individual fields from JSONObject
		try {
			res = res.messageID(jo.getInt(SERIALIZED_NAME_MESSAGE_I_D));
			res = res.repeatIndicator(jo.getInt(SERIALIZED_NAME_REPEAT_INDICATOR));
			res = res.userID(jo.getInt(SERIALIZED_NAME_USER_I_D));
			res = res.valid(jo.getBoolean(SERIALIZED_NAME_VALID));
			abm = (AddressedBinaryMessage) res;
			abm = abm.sequenceinteger(jo.getInt(SERIALIZED_NAME_SEQUENCEINTEGER));
			abm = abm.destinationID(jo.getInt(SERIALIZED_NAME_DESTINATION_I_D));
			abm = abm.retransmission(jo.getBoolean(SERIALIZED_NAME_RETRANSMISSION));
			// XXX spare
			JSONObject data = jo.getJSONObject(SERIALIZED_NAME_APPLICATION_I_D);
			abm = abm.applicationID(AddressedBinaryMessageApplicationID.fromJson(data));
			abm = abm.binaryData(jo.getString(SERIALIZED_NAME_BINARY_DATA));
//			System.out.println(abm);
		} catch (JSONException e) {
//			logger.error("Error creating AddressedBinaryMessage", e);
			System.out.println("Error creating AddressedBinaryMessage " + e);
		}
		return abm;
	}

}

